# -*- coding: utf-8 -*-
"""통계데이터분석-KMeans 군집화.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dBVdtihA5-a3hSblZfm7yLrDnOX42Z2s
"""

def distance(x1,x2):
  return sum((x1-x2)**2)**(1/2)

import numpy as np
na1 = np.array([1,2])
na2 = np.array([5,5])
print(distance(na1,na2))

"""KMeans"""

def kmeans(data,k=3):
  centers=[]
  dl = len(data)
  #초기에 k개의 중심점을 선택한다. (무엇을 중심점으로 선택하는 것이 좋은지는 여기에서는 생략)
  for center in range(k):
    ci = np.random.randint(dl) #현재 데이터 중에 하나를 고르기 위함(ci는 선택 인덱스)
    centers.append(data[ci])  #선택한 점을 초기 중심점으로 결정

  while True:#반복
    #모든 데이터를 중심점과의 거리를 계산하여 가까운 중심점 그룹에 속하게 한다.     
    cs = {}
    for elem in data: #모든 점들을
      distances=[]
      for i in range(k): #모든 중심점들과
        dis = distance(centers[i], elem) #i번째 중심점과 elem 사이에 거리를 계산한다.
        distances.append(dis)
      nd = np.array(distances)
      ai = nd.argmin() #최소 거리에 해당하는 인덱스를 구하여라.(그룹 인덱스)
      
      if ai in cs: #해당 인덱스가 처음 선택한 인덱스일 때
        cs[ai].append(elem) #해당 그룹에 elem(점)을 소속시킨다.
      else: #그렇지 않다면
        cs[ai] = [] #사전 개체에 빈 리스트 생성
        cs[ai].append(elem) #리스트에 elem을 소속시킨다.

    #그룹의 중심점을 계산한다.
    rcenters=[]
    for i in range(k):#k개의 그룹에 관하여
      sx = np.array([x for x,_ in cs[i]])
      sy = np.array([y for _,y in cs[i]])
      rcenters.append([sx.mean(), sy.mean()])
    if np.array_equal(centers,rcenters):#만약 이전 중심점과 새로운 중심점이 서로 같으면
       break#루프 탈출
    else:
      centers = rcenters    
  return cs

data = np.array([[np.random.randint(0,100),np.random.randint(0,100)] for _ in range(50)])
len(data)

re_cl = kmeans(data)

import matplotlib.pyplot as plt
plt.plot(np.array([x for x,_ in re_cl[0]]),np.array([y for _,y in re_cl[0]]),'b.')
plt.plot(np.array([x for x,_ in re_cl[1]]),np.array([y for _,y in re_cl[1]]),'ro')
plt.plot(np.array([x for x,_ in re_cl[2]]),np.array([y for _,y in re_cl[2]]),'g*')
plt.show()